"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[1935],{1618(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"integration/frontend","title":"Frontend Integration","description":"Integrating with the STELLA backend from your frontend","source":"@site/docs/integration/frontend.md","sourceDirName":"integration","slug":"/integration/frontend","permalink":"/STELLA_backend/docs/integration/frontend","draft":false,"unlisted":false,"editUrl":"https://github.com/c4dhi/STELLA_backend/tree/main/docs-site/docs/integration/frontend.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Frontend Integration","description":"Integrating with the STELLA backend from your frontend"},"sidebar":"docsSidebar","previous":{"title":"LiveKit Production","permalink":"/STELLA_backend/docs/integration/livekit-production"},"next":{"title":"Contributing Overview","permalink":"/STELLA_backend/docs/contributing/"}}');var i=t(4848),o=t(8453);const r={sidebar_position:2,title:"Frontend Integration",description:"Integrating with the STELLA backend from your frontend"},a="Frontend Integration",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Installation",id:"installation",level:2},{value:"API Client Setup",id:"api-client-setup",level:2},{value:"REST API Client",id:"rest-api-client",level:3},{value:"TypeScript Types",id:"typescript-types",level:3},{value:"LiveKit Integration",id:"livekit-integration",level:2},{value:"Connection Component",id:"connection-component",level:3},{value:"Chat Interface",id:"chat-interface",level:3},{value:"Microphone Control",id:"microphone-control",level:3},{value:"WebSocket Updates",id:"websocket-updates",level:2},{value:"Real-time Session Updates",id:"real-time-session-updates",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Session Page",id:"session-page",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"frontend-integration",children:"Frontend Integration"})}),"\n",(0,i.jsx)(e.p,{children:"This guide covers how to integrate your frontend application with the STELLA backend API and LiveKit for real-time communication."}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Your Frontend  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  STELLA Backend  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  LiveKit Server  \u2502\n\u2502     (React)      \u2502     \u2502   (REST + WS)    \u2502     \u2502    (WebRTC)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"npm install @livekit/components-react livekit-client\n"})}),"\n",(0,i.jsx)(e.h2,{id:"api-client-setup",children:"API Client Setup"}),"\n",(0,i.jsx)(e.h3,{id:"rest-api-client",children:"REST API Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// lib/api.ts\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';\n\nclass StellaAPI {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = API_URL) {\n    this.baseUrl = baseUrl;\n  }\n\n  private async request<T>(\n    path: string,\n    options?: RequestInit\n  ): Promise<T> {\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`API error: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  // Projects\n  async getProjects() {\n    return this.request<Project[]>('/api/projects');\n  }\n\n  async createProject(data: CreateProjectDto) {\n    return this.request<Project>('/api/projects', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  }\n\n  // Sessions\n  async createSession(data: CreateSessionDto) {\n    return this.request<Session>('/api/sessions', {\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n  }\n\n  async getSession(sessionId: string) {\n    return this.request<Session>(`/api/sessions/${sessionId}`);\n  }\n\n  async endSession(sessionId: string) {\n    return this.request<void>(`/api/sessions/${sessionId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  async joinSession(sessionId: string) {\n    return this.request<JoinResponse>(`/api/sessions/${sessionId}/join`, {\n      method: 'POST',\n    });\n  }\n\n  async getSessionMessages(sessionId: string) {\n    return this.request<Message[]>(`/api/sessions/${sessionId}/messages`);\n  }\n}\n\nexport const api = new StellaAPI();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"typescript-types",children:"TypeScript Types"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// types/api.ts\nexport interface Project {\n  id: string;\n  name: string;\n  description?: string;\n  createdAt: string;\n}\n\nexport interface Session {\n  id: string;\n  projectId: string;\n  status: 'PENDING' | 'CONNECTING' | 'ACTIVE' | 'ENDING' | 'ENDED';\n  agentType: string;\n  roomName: string;\n  createdAt: string;\n}\n\nexport interface JoinResponse {\n  token: string;\n  url: string;\n}\n\nexport interface Message {\n  id: string;\n  sessionId: string;\n  speaker: 'user' | 'assistant';\n  content: string;\n  timestamp: string;\n}\n\nexport interface CreateSessionDto {\n  projectId: string;\n  agentType: 'stella-agent' | 'stella-light' | 'echo-agent';\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"livekit-integration",children:"LiveKit Integration"}),"\n",(0,i.jsx)(e.h3,{id:"connection-component",children:"Connection Component"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"// components/VoiceChat.tsx\nimport {\n  LiveKitRoom,\n  RoomAudioRenderer,\n  useLocalParticipant,\n  useDataChannel,\n} from '@livekit/components-react';\nimport { useState, useCallback, useEffect } from 'react';\n\ninterface VoiceChatProps {\n  sessionId: string;\n  onMessage?: (message: any) => void;\n}\n\nexport function VoiceChat({ sessionId, onMessage }: VoiceChatProps) {\n  const [token, setToken] = useState<string | null>(null);\n  const [url, setUrl] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function join() {\n      try {\n        const response = await api.joinSession(sessionId);\n        setToken(response.token);\n        setUrl(response.url);\n      } catch (err) {\n        setError(err.message);\n      }\n    }\n    join();\n  }, [sessionId]);\n\n  if (error) {\n    return <div className=\"error\">Failed to join: {error}</div>;\n  }\n\n  if (!token || !url) {\n    return <div className=\"loading\">Connecting...</div>;\n  }\n\n  return (\n    <LiveKitRoom\n      serverUrl={url}\n      token={token}\n      connect={true}\n      audio={true}\n      video={false}\n    >\n      <RoomAudioRenderer />\n      <ChatInterface onMessage={onMessage} />\n    </LiveKitRoom>\n  );\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"chat-interface",children:"Chat Interface"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"// components/ChatInterface.tsx\nimport { useDataChannel, useLocalParticipant } from '@livekit/components-react';\nimport { useState, useCallback, useEffect } from 'react';\n\nexport function ChatInterface({ onMessage }) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [status, setStatus] = useState<string>('idle');\n  const [inputText, setInputText] = useState('');\n  const { localParticipant } = useLocalParticipant();\n\n  // Handle incoming data messages\n  const handleDataReceived = useCallback((payload: Uint8Array) => {\n    const message = JSON.parse(new TextDecoder().decode(payload));\n\n    if (message.type === 'transcript') {\n      if (message.data.isFinal) {\n        setMessages(prev => [...prev, {\n          speaker: message.data.speaker,\n          text: message.data.text,\n          timestamp: new Date(message.timestamp),\n        }]);\n      }\n    } else if (message.type === 'status') {\n      setStatus(message.data.status);\n    }\n\n    onMessage?.(message);\n  }, [onMessage]);\n\n  useDataChannel(handleDataReceived);\n\n  // Send text message\n  const sendTextMessage = useCallback(async (text: string) => {\n    if (!localParticipant || !text.trim()) return;\n\n    const message = {\n      type: 'user_text',\n      timestamp: Date.now(),\n      data: text,\n    };\n\n    await localParticipant.publishData(\n      new TextEncoder().encode(JSON.stringify(message)),\n      { reliable: true }\n    );\n\n    setMessages(prev => [...prev, {\n      speaker: 'user',\n      text,\n      timestamp: new Date(),\n    }]);\n\n    setInputText('');\n  }, [localParticipant]);\n\n  return (\n    <div className=\"chat-interface\">\n      <div className=\"status-bar\">\n        <AgentStatus status={status} />\n      </div>\n\n      <div className=\"messages\">\n        {messages.map((msg, i) => (\n          <MessageBubble key={i} message={msg} />\n        ))}\n      </div>\n\n      <div className=\"input-area\">\n        <MicrophoneButton />\n        <input\n          type=\"text\"\n          value={inputText}\n          onChange={e => setInputText(e.target.value)}\n          onKeyPress={e => e.key === 'Enter' && sendTextMessage(inputText)}\n          placeholder=\"Type a message...\"\n        />\n        <button onClick={() => sendTextMessage(inputText)}>\n          Send\n        </button>\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"microphone-control",children:"Microphone Control"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"// components/MicrophoneButton.tsx\nimport { useLocalParticipant } from '@livekit/components-react';\nimport { useState } from 'react';\n\nexport function MicrophoneButton() {\n  const { localParticipant } = useLocalParticipant();\n  const [isMuted, setIsMuted] = useState(false);\n\n  const toggleMute = async () => {\n    if (!localParticipant) return;\n\n    await localParticipant.setMicrophoneEnabled(isMuted);\n    setIsMuted(!isMuted);\n  };\n\n  return (\n    <button\n      onClick={toggleMute}\n      className={`mic-button ${isMuted ? 'muted' : 'active'}`}\n      aria-label={isMuted ? 'Unmute' : 'Mute'}\n    >\n      {isMuted ? <MicOffIcon /> : <MicIcon />}\n    </button>\n  );\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"websocket-updates",children:"WebSocket Updates"}),"\n",(0,i.jsx)(e.h3,{id:"real-time-session-updates",children:"Real-time Session Updates"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// hooks/useSessionUpdates.ts\nimport { useEffect, useCallback } from 'react';\n\nexport function useSessionUpdates(\n  sessionId: string,\n  onUpdate: (event: SessionEvent) => void\n) {\n  useEffect(() => {\n    const ws = new WebSocket(\n      `${WS_URL}/sessions/${sessionId}/ws`\n    );\n\n    ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      onUpdate(data);\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n\n    return () => {\n      ws.close();\n    };\n  }, [sessionId, onUpdate]);\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(e.h3,{id:"session-page",children:"Session Page"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"// pages/session/[id].tsx\nimport { useRouter } from 'next/router';\nimport { useEffect, useState } from 'react';\nimport { VoiceChat } from '@/components/VoiceChat';\nimport { api } from '@/lib/api';\n\nexport default function SessionPage() {\n  const router = useRouter();\n  const { id } = router.query;\n  const [session, setSession] = useState<Session | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (!id) return;\n\n    async function loadSession() {\n      try {\n        const data = await api.getSession(id as string);\n        setSession(data);\n      } catch (err) {\n        console.error('Failed to load session:', err);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadSession();\n  }, [id]);\n\n  const handleEndSession = async () => {\n    if (!session) return;\n\n    await api.endSession(session.id);\n    router.push('/');\n  };\n\n  if (loading) {\n    return <div>Loading session...</div>;\n  }\n\n  if (!session) {\n    return <div>Session not found</div>;\n  }\n\n  return (\n    <div className=\"session-page\">\n      <header>\n        <h1>Session: {session.id}</h1>\n        <span className=\"status\">{session.status}</span>\n        <button onClick={handleEndSession}>End Session</button>\n      </header>\n\n      {session.status === 'ACTIVE' && (\n        <VoiceChat sessionId={session.id} />\n      )}\n\n      {session.status === 'PENDING' && (\n        <div className=\"connecting\">\n          <span>Connecting to agent...</span>\n        </div>\n      )}\n\n      {session.status === 'ENDED' && (\n        <div className=\"ended\">\n          <span>Session ended</span>\n          <a href=\"/\">Start new session</a>\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"// lib/errors.ts\nexport class APIError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'APIError';\n  }\n}\n\n// Usage in API client\nprivate async request<T>(path: string, options?: RequestInit): Promise<T> {\n  const response = await fetch(`${this.baseUrl}${path}`, options);\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({}));\n    throw new APIError(\n      error.message || response.statusText,\n      response.status,\n      error.code\n    );\n  }\n\n  return response.json();\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/integration/livekit",children:"LiveKit Integration"})," - LiveKit setup"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/guides/add-custom-ui",children:"Add Custom UI"})," - UI customization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"/docs/architecture/overview",children:"Architecture Overview"})," - System architecture"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);