"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[8599],{8453(e,n,s){s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},9660(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"contributing/coding-standards/testing","title":"Testing","description":"Testing standards and practices for STELLA","source":"@site/docs/contributing/coding-standards/testing.md","sourceDirName":"contributing/coding-standards","slug":"/contributing/coding-standards/testing","permalink":"/STELLA_backend/docs/contributing/coding-standards/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/c4dhi/STELLA_backend/tree/main/docs-site/docs/contributing/coding-standards/testing.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Testing","description":"Testing standards and practices for STELLA"},"sidebar":"docsSidebar","previous":{"title":"Git & Commits","permalink":"/STELLA_backend/docs/contributing/coding-standards/git"},"next":{"title":"Pull Request Process","permalink":"/STELLA_backend/docs/contributing/pull-request-process"}}');var r=s(4848),i=s(8453);const a={sidebar_position:6,title:"Testing",description:"Testing standards and practices for STELLA"},o="Testing",c={},l=[{value:"Backend (NestJS)",id:"backend-nestjs",level:2},{value:"Running Tests",id:"running-tests",level:3},{value:"Test Structure",id:"test-structure",level:3},{value:"Frontend (React)",id:"frontend-react",level:2},{value:"Running Tests",id:"running-tests-1",level:3},{value:"Component Testing",id:"component-testing",level:3},{value:"Hook Testing",id:"hook-testing",level:3},{value:"Agents (Python)",id:"agents-python",level:2},{value:"Running Tests",id:"running-tests-2",level:3},{value:"Test Structure",id:"test-structure-1",level:3},{value:"Testing Tools",id:"testing-tools",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"General",id:"general",level:3},{value:"Coverage Goals",id:"coverage-goals",level:3},{value:"What to Test",id:"what-to-test",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"testing",children:"Testing"})}),"\n",(0,r.jsx)(n.p,{children:"Testing standards and practices for all STELLA components."}),"\n",(0,r.jsx)(n.h2,{id:"backend-nestjs",children:"Backend (NestJS)"}),"\n",(0,r.jsx)(n.h3,{id:"running-tests",children:"Running Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run all tests\nnpm test\n\n# Run with coverage\nnpm run test:cov\n\n# Run specific test file\nnpm test -- session.service.spec.ts\n\n# Run tests in watch mode\nnpm run test:watch\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-structure",children:"Test Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Test, TestingModule } from '@nestjs/testing';\nimport { SessionService } from './session.service';\nimport { PrismaService } from '../prisma/prisma.service';\n\ndescribe('SessionService', () => {\n  let service: SessionService;\n  let prisma: PrismaService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        SessionService,\n        {\n          provide: PrismaService,\n          useValue: {\n            session: {\n              create: jest.fn(),\n              findUnique: jest.fn(),\n            },\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<SessionService>(SessionService);\n    prisma = module.get<PrismaService>(PrismaService);\n  });\n\n  describe('create', () => {\n    it('should create a session with pending status', async () => {\n      const dto = { projectId: 'proj-1', agentType: 'stella-agent' };\n      const expected = { id: 'sess-1', ...dto, status: 'PENDING' };\n\n      jest.spyOn(prisma.session, 'create').mockResolvedValue(expected);\n\n      const result = await service.create(dto);\n\n      expect(result).toEqual(expected);\n      expect(prisma.session.create).toHaveBeenCalledWith({\n        data: { ...dto, status: 'PENDING' },\n      });\n    });\n  });\n\n  describe('findOne', () => {\n    it('should return session if found', async () => {\n      const session = { id: 'sess-1', status: 'ACTIVE' };\n      jest.spyOn(prisma.session, 'findUnique').mockResolvedValue(session);\n\n      const result = await service.findOne('sess-1');\n\n      expect(result).toEqual(session);\n    });\n\n    it('should throw NotFoundException if session not found', async () => {\n      jest.spyOn(prisma.session, 'findUnique').mockResolvedValue(null);\n\n      await expect(service.findOne('invalid')).rejects.toThrow(\n        'Session invalid not found',\n      );\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"frontend-react",children:"Frontend (React)"}),"\n",(0,r.jsx)(n.h3,{id:"running-tests-1",children:"Running Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run tests\nnpm test\n\n# Run with coverage\nnpm run test:coverage\n\n# Run in watch mode\nnpm run test:watch\n"})}),"\n",(0,r.jsx)(n.h3,{id:"component-testing",children:"Component Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { render, screen, fireEvent } from '@testing-library/react';\nimport { Message } from './Message';\n\ndescribe('Message', () => {\n  it('renders the message text', () => {\n    render(<Message text=\"Hello\" speaker=\"user\" />);\n\n    expect(screen.getByText('Hello')).toBeInTheDocument();\n  });\n\n  it('applies correct class for speaker', () => {\n    const { container } = render(<Message text=\"Hi\" speaker=\"assistant\" />);\n\n    expect(container.firstChild).toHaveClass('message--assistant');\n  });\n\n  it('shows timestamp when provided', () => {\n    const date = new Date('2024-01-15T10:30:00');\n    render(<Message text=\"Test\" speaker=\"user\" timestamp={date} />);\n\n    expect(screen.getByText(/10:30/)).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hook-testing",children:"Hook Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { renderHook, waitFor } from '@testing-library/react';\nimport { useSession } from './useSession';\nimport { api } from '../api';\n\njest.mock('../api');\n\ndescribe('useSession', () => {\n  it('fetches session data', async () => {\n    const mockSession = { id: 'sess-1', status: 'ACTIVE' };\n    (api.getSession as jest.Mock).mockResolvedValue(mockSession);\n\n    const { result } = renderHook(() => useSession('sess-1'));\n\n    expect(result.current.loading).toBe(true);\n\n    await waitFor(() => {\n      expect(result.current.loading).toBe(false);\n    });\n\n    expect(result.current.session).toEqual(mockSession);\n    expect(result.current.error).toBeNull();\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"agents-python",children:"Agents (Python)"}),"\n",(0,r.jsx)(n.h3,{id:"running-tests-2",children:"Running Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run all tests\npytest\n\n# Run with coverage\npytest --cov=src\n\n# Run specific test file\npytest tests/test_agent.py\n\n# Run specific test\npytest tests/test_agent.py::test_greeting\n\n# Run with verbose output\npytest -v\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-structure-1",children:"Test Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'"""Tests for the customer support agent."""\n\nimport pytest\nfrom unittest.mock import AsyncMock, patch\n\nfrom stella_agent.agent import CustomerSupportAgent\n\n\n@pytest.fixture\ndef agent():\n    """Create a test agent instance."""\n    return CustomerSupportAgent()\n\n\n@pytest.fixture\ndef mock_openai():\n    """Mock OpenAI client."""\n    with patch(\'stella_agent.agent.AsyncOpenAI\') as mock:\n        client = AsyncMock()\n        mock.return_value = client\n        yield client\n\n\nclass TestCustomerSupportAgent:\n    """Tests for CustomerSupportAgent."""\n\n    @pytest.mark.asyncio\n    async def test_on_connect_sends_greeting(self, agent):\n        """Agent should send greeting on connect."""\n        agent.speak = AsyncMock()\n\n        await agent.on_connect()\n\n        agent.speak.assert_called_once()\n        assert "help" in agent.speak.call_args[0][0].lower()\n\n    @pytest.mark.asyncio\n    async def test_on_transcript_ignores_partial(self, agent):\n        """Agent should ignore non-final transcripts."""\n        agent._generate_response = AsyncMock()\n\n        await agent.on_transcript("Hello", is_final=False)\n\n        agent._generate_response.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_on_transcript_processes_final(self, agent, mock_openai):\n        """Agent should process final transcripts."""\n        agent.speak = AsyncMock()\n        mock_openai.chat.completions.create.return_value.choices[0].message.content = "Hi there!"\n\n        await agent.on_transcript("Hello", is_final=True)\n\n        assert len(agent.history) == 1\n        assert agent.history[0]["content"] == "Hello"\n        agent.speak.assert_called_once_with("Hi there!")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"testing-tools",children:"Testing Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'"""Tests for agent tools."""\n\nimport pytest\nfrom unittest.mock import AsyncMock, patch\n\nfrom stella_agent.tools import search_knowledge\n\n\n@pytest.mark.asyncio\nasync def test_search_knowledge_returns_results():\n    """Search should return formatted results."""\n    mock_results = [\n        type(\'Article\', (), {\'title\': \'FAQ\', \'summary\': \'Common questions\'})(),\n    ]\n\n    with patch(\'stella_agent.tools.db.search\', new_callable=AsyncMock) as mock_search:\n        mock_search.return_value = mock_results\n\n        result = await search_knowledge("help")\n\n        assert result["found"] is True\n        assert len(result["articles"]) == 1\n        assert result["articles"][0]["title"] == "FAQ"\n\n\n@pytest.mark.asyncio\nasync def test_search_knowledge_handles_no_results():\n    """Search should handle empty results."""\n    with patch(\'stella_agent.tools.db.search\', new_callable=AsyncMock) as mock_search:\n        mock_search.return_value = []\n\n        result = await search_knowledge("nonexistent")\n\n        assert result["found"] is False\n        assert result["articles"] == []\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"general",children:"General"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Write tests before or alongside code (TDD/BDD)"}),"\n",(0,r.jsx)(n.li,{children:"Test behavior, not implementation"}),"\n",(0,r.jsx)(n.li,{children:"Use descriptive test names that explain the scenario"}),"\n",(0,r.jsx)(n.li,{children:"Keep tests focused and independent"}),"\n",(0,r.jsx)(n.li,{children:"Avoid testing external dependencies directly"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"coverage-goals",children:"Coverage Goals"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Target Coverage"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Backend"}),(0,r.jsx)(n.td,{children:"80%+"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Frontend"}),(0,r.jsx)(n.td,{children:"70%+"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Agents"}),(0,r.jsx)(n.td,{children:"80%+"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"what-to-test",children:"What to Test"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Do test:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Business logic and edge cases"}),"\n",(0,r.jsx)(n.li,{children:"Error handling"}),"\n",(0,r.jsx)(n.li,{children:"User interactions"}),"\n",(0,r.jsx)(n.li,{children:"API contracts"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Don't test:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Framework code"}),"\n",(0,r.jsx)(n.li,{children:"Third-party libraries"}),"\n",(0,r.jsx)(n.li,{children:"Simple getters/setters"}),"\n",(0,r.jsx)(n.li,{children:"Implementation details"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);